package org.ostelco.prime.storage.scaninfo

import arrow.core.Either
import arrow.core.fix
import arrow.core.right
import arrow.effects.IO
import arrow.instances.either.monad.monad
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.google.cloud.NoCredentials
import com.google.cloud.datastore.Blob
import com.google.cloud.datastore.Datastore
import com.google.cloud.datastore.DatastoreException
import com.google.cloud.datastore.DatastoreOptions
import com.google.cloud.datastore.Entity
import com.google.cloud.datastore.KeyFactory
import com.google.cloud.datastore.testing.LocalDatastoreHelper
import com.google.cloud.http.HttpTransportOptions
import com.google.cloud.storage.BlobId
import com.google.cloud.storage.BlobInfo
import com.google.cloud.storage.StorageException
import com.google.cloud.storage.StorageOptions
import com.google.crypto.tink.CleartextKeysetHandle
import com.google.crypto.tink.JsonKeysetReader
import com.google.crypto.tink.config.TinkConfig
import com.google.crypto.tink.hybrid.HybridDecryptFactory
import io.dropwizard.setup.Environment
import org.ostelco.prime.getLogger
import org.ostelco.prime.model.JumioScanData
import org.ostelco.prime.model.ScanMetadata
import org.ostelco.prime.model.ScanMetadataEnum
import org.ostelco.prime.model.VendorScanData
import org.ostelco.prime.model.VendorScanInformation
import org.ostelco.prime.storage.FileDeleteError
import org.ostelco.prime.storage.FileDownloadError
import org.ostelco.prime.storage.NotCreatedError
import org.ostelco.prime.storage.ScanInformationStore
import org.ostelco.prime.storage.StoreError
import java.io.BufferedOutputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileNotFoundException
import java.io.FileOutputStream
import java.io.IOException
import java.net.HttpURLConnection
import java.net.URL
import java.time.Instant
import java.util.*
import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream
import java.util.zip.ZipOutputStream
import javax.ws.rs.core.MultivaluedMap
import kotlin.collections.HashMap


class ScanInfoStore : ScanInformationStore by ScanInformationStoreSingleton

/**
 * Helper class for getting environment variables.
 * Introduced to help testing.
 */
open class EnvironmentVars {
    /**
     * Retrieve the value of the environment variable.
     */
    open fun getVar(name: String): String? = System.getenv(name)
}

/**
 * Object implementing the Cloud-Storage, Jumio based Scan Store
 */
object ScanInformationStoreSingleton : ScanInformationStore {

    private val logger by getLogger()

    private lateinit var datastore: Datastore
    private lateinit var keyFactory: KeyFactory

    // Used by unit tests
    private lateinit var localDatastoreHelper: LocalDatastoreHelper

    /* Generated by Jumio and can be obtained from the console. */
    private lateinit var apiToken: String
    private lateinit var apiSecret: String

    // Cloud storage bucket prefix for storing zip files
    private lateinit var storageBucket: String

    private var deleteScan: Boolean = false
    private lateinit var deleteUrl: String

    // Path name prefix for the keyset files.
    private lateinit var keysetFilePathPrefix: String
    // KMS key name for decrypting the public key set.
    private var masterKeyUri: String? = null
    // Encryptors for used for each country
    private var encrypters:HashMap<String, ScanInfoEncrypt> = HashMap()

    private fun getEncrypter(countryCode: String): ScanInfoEncrypt {
        if (encrypters.containsKey(countryCode)) {
            return encrypters[countryCode]!!
        } else {
            logger.info("Initializing ScanInfoEncrypt for country:${countryCode}")
            val encrypt = ScanInfoEncrypt("${keysetFilePathPrefix}_${countryCode}", masterKeyUri)
            encrypters.put(countryCode, encrypt)
            return encrypt
        }
    }

    /**
     * Save the scan information in cloud storage.
     * Downloads images and create the zip file. The zip file is then
     * encrypted with the keys for right buckets.
     *  - Saves the zip files in two locations,
     *  1) <bucket>-global/<customer-id>/<scan-id>.zip.tk
     *  2) <bucket>-<country-code>/<customer-id>/<scan-id>.zip.tk
     */
    override fun upsertVendorScanInformation(customerId: String, countryCode:String, vendorData: MultivaluedMap<String, String>): Either<StoreError, Unit> {
        return IO {
            Either.monad<StoreError>().binding {
                val vendorScanInformation = createVendorScanInformation(vendorData).bind()
                val bucketName = storageBucket
                val plainZipData = JumioHelper.generateZipFile(vendorScanInformation).bind()
                val zipData = getEncrypter("global").encryptData(plainZipData)
                if (bucketName.isNullOrEmpty()) {
                    val fileName = "${countryCode}_${vendorScanInformation.id}.zip.tk"
                    logger.info("No bucket set, saving file locally $fileName")
                    JumioHelper.saveLocalFile(fileName, zipData).bind()
                } else {
                    val fileName = "${customerId}/${vendorScanInformation.id}.zip.tk"
                    val globalBucket = "${bucketName}-global"
                    val countryBucket = "${bucketName}-${countryCode.toLowerCase()}"
                    logger.info("Saving in cloud storage $globalBucket --> $fileName")
                    JumioHelper.uploadFileToCloudStorage(globalBucket, fileName, zipData).bind()
                    if (countryBucket != globalBucket) {
                        logger.info("Saving in cloud storage $countryBucket --> $fileName")
                        val localZipData = getEncrypter(countryCode).encryptData(plainZipData)
                        JumioHelper.uploadFileToCloudStorage(countryBucket, fileName, localZipData).bind()
                    }
                }
                saveScanMetaData(customerId, countryCode, vendorScanInformation).bind()
                Unit
            }.fix()
        }.unsafeRunSync()
    }

    private fun createVendorScanInformation(vendorData: MultivaluedMap<String, String>): Either<StoreError, VendorScanInformation> {
        return JumioHelper.generateVendorScanInformation(vendorData, apiToken, apiSecret)
    }

    private fun saveScanMetaData(customerId: String, countryCode:String, vendorScanInformation:VendorScanInformation): Either<StoreError, Unit> {
        val keyString = "$customerId-${vendorScanInformation.id}"
        try {
            val key = keyFactory.newKey(keyString)
            val entity = Entity.newBuilder(key)
                    .set(ScanMetadataEnum.ID.s, vendorScanInformation.id)
                    .set(ScanMetadataEnum.SCAN_REFERENCE.s, vendorScanInformation.scanReference)
                    .set(ScanMetadataEnum.COUNTRY_CODE.s, countryCode)
                    .set(ScanMetadataEnum.CUSTOMER_ID.s, customerId)
                    .set(ScanMetadataEnum.PROCESSED_TIME.s, Instant.now().toEpochMilli())
                    .build()
            datastore.add(entity)
            logger.error("Saved ScanMetaData for ${keyString}")
        } catch (e: DatastoreException) {
            logger.error("Caught exception while storing the scan meta data", e)
            return Either.left(NotCreatedError("ScanMetaData", keyString))
        }
        return Unit.right()
    }

    // Internal function used by unit test to check the encrypted zip file
    internal fun __getVendorScanInformationFile(customerId: String, countryCode:String, scanId: String): Either<StoreError, String> {
        return Either.right("${countryCode}_$scanId.zip.tk")
    }
    // Internal function used by unit test to check the scan meta data
    internal fun __getScanMetaData(customerId: String, scanId: String): ScanMetadata? {
        val keyString = "$customerId-$scanId"
        try {
            val key = keyFactory.newKey(keyString)
            val entity = datastore.get(key)
            return ScanMetadata(
                    id = entity.getString(ScanMetadataEnum.ID.s),
                    scanReference = entity.getString(ScanMetadataEnum.SCAN_REFERENCE.s),
                    countryCode = entity.getString(ScanMetadataEnum.COUNTRY_CODE.s),
                    customerId = entity.getString(ScanMetadataEnum.CUSTOMER_ID.s),
                    processedTime = entity.getLong(ScanMetadataEnum.PROCESSED_TIME.s)
            )
        } catch (e: DatastoreException) {
            logger.error("Caught exception while retreiving scan meta data", e)
        }
        return null
    }

    // Initialize the object, get all the environment variables and initialize the encrypter library.
    fun init(env: Environment?, environmentVars: EnvironmentVars) {
        TinkConfig.register()
        keysetFilePathPrefix = ConfigRegistry.config.keysetFilePathPrefix
        val storeType = ConfigRegistry.config.storeType
        if (storeType != "emulator" && storeType != "inmemory-emulator") {
            apiToken = environmentVars.getVar("JUMIO_API_TOKEN")
                    ?: throw Error("Missing environment variable JUMIO_API_TOKEN")
            apiSecret = environmentVars.getVar("JUMIO_API_SECRET")
                    ?: throw Error("Missing environment variable JUMIO_API_SECRET")
            storageBucket = environmentVars.getVar("SCANINFO_STORAGE_BUCKET")
                    ?: throw Error("Missing environment variable SCANINFO_STORAGE_BUCKET")
            masterKeyUri = environmentVars.getVar("SCANINFO_MASTERKEY_URI")
                    ?: throw Error("Missing environment variable SCANINFO_MASTERKEY_URI")
        } else {
            // Don't throw error during local tests
            apiToken = ""
            apiSecret = ""
            storageBucket = ""
            masterKeyUri = null
        }
        initDatastore(env)
    }

    fun cleanup() {
        if (ConfigRegistry.config.storeType == "inmemory-emulator") {
            // Stop the emulator after unit tests.
            localDatastoreHelper.stop()
        }
    }

    // Integration testing helper for Datastore.
    private fun initDatastore(env: Environment?) {
        datastore = when (ConfigRegistry.config.storeType) {
            "inmemory-emulator" -> {
                logger.info("Starting with in-memory datastore emulator")
                localDatastoreHelper = LocalDatastoreHelper.create(1.0)
                localDatastoreHelper.start()
                localDatastoreHelper.options
            }
            "emulator" -> {
                // When prime running in GCP by hosted CI/CD, Datastore client library assumes it is running in
                // production and ignore our instruction to connect to the datastore emulator. So, we are explicitly
                // connecting to emulator
                logger.info("Connecting to datastore emulator")
                DatastoreOptions
                        .newBuilder()
                        .setHost("localhost:9090")
                        .setCredentials(NoCredentials.getInstance())
                        .setTransportOptions(HttpTransportOptions.newBuilder().build())
                        .build()
            }
            else -> {
                logger.info("Created default instance of datastore client")
                DatastoreOptions
                        .newBuilder()
                        .setNamespace(ConfigRegistry.config.namespace)
                        .build()
            }
        }.service
        keyFactory =  datastore.newKeyFactory().setKind(ScanMetadataEnum.KIND.s)
    }
}

/**
 * A utility for downloading and creating the scan information for Jumio clients.
 */
object JumioHelper {
    private val logger by getLogger()
    /**
     * Retrieves the contents of a file from a URL
     */
    private fun downloadFileAsBlob(fileURL: String, username: String, password: String): Either<StoreError, Pair<Blob, String>> {
        val url = URL(fileURL)
        val httpConn = url.openConnection() as HttpURLConnection
        val userpass = "$username:$password"
        val authHeader = "Basic ${Base64.getEncoder().encodeToString(userpass.toByteArray())}"
        httpConn.setRequestProperty("Authorization", authHeader)

        try {
            val responseCode = httpConn.responseCode
            // always check HTTP response code first
            if (responseCode != HttpURLConnection.HTTP_OK) {
                val statusMessage = "$responseCode: ${httpConn.responseMessage}"
                return Either.left(FileDownloadError(fileURL, statusMessage))
            }
            val contentType = httpConn.contentType
            val inputStream = httpConn.inputStream
            val fileData = Blob.copyFrom(inputStream)
            inputStream.close()
            return Either.right(Pair(fileData, contentType))
        } catch (e: IOException) {
            val statusMessage = "IOException: $e"
            return Either.left(FileDownloadError(fileURL, statusMessage))
        } finally {
            httpConn.disconnect()
        }
    }

    private fun isJSONArray(jsonData: String): Boolean {
        try {
            val mapper = ObjectMapper()
            return mapper.readTree(jsonData).isArray
        } catch (e: IOException) {
            return false
        }
    }

    private fun flattenList(list: List<String>): List<String> {
        try {
            if (list.size > 1) {
                return list //already flattened.
            }
            val jsonData:String = list[0]
            if (isJSONArray(jsonData)) {
                return ObjectMapper().readValue(jsonData)
            }
        } catch (e: IOException) {
            logger.error("Cannot flattenList Json Data $list", e)
        }
        return list;
    }

    /**
     * Creates the VendorScanInformation from the input map.
     * - Downloads all the required images
     */
    fun generateVendorScanInformation(vendorData: MultivaluedMap<String, String>, apiToken: String, apiSecret: String): Either<StoreError, VendorScanInformation> {
        var images:MutableMap<String, Blob> = mutableMapOf<String, Blob>()

        val scanId: String = vendorData.getFirst(JumioScanData.SCAN_ID.s)
        val scanReference: String = vendorData.getFirst(JumioScanData.JUMIO_SCAN_ID.s)
        val scanDetails: String = ObjectMapper().writeValueAsString(vendorData)
        val scanImageUrl: String? = vendorData.getFirst(JumioScanData.SCAN_IMAGE.s)
        val scanImageBacksideUrl: String? = vendorData.getFirst(JumioScanData.SCAN_IMAGE_BACKSIDE.s)
        val scanImageFaceUrl: String? = vendorData.getFirst(JumioScanData.SCAN_IMAGE_FACE.s)
        val scanlivenessImagesUrl: List<String>? = vendorData[JumioScanData.SCAN_LIVENESS_IMAGES.s]

        return IO {
            Either.monad<StoreError>().binding {
                var result: Pair<Blob, String>
                if (scanImageUrl != null) {
                    result = downloadFileAsBlob(scanImageUrl, apiToken, apiSecret).bind()
                    val filename = "id.${getFileExtFromType(result.second)}"
                    images.put(filename, result.first)
                }
                if (scanImageBacksideUrl != null) {
                    result = downloadFileAsBlob(scanImageBacksideUrl, apiToken, apiSecret).bind()
                    val filename = "id_backside.${getFileExtFromType(result.second)}"
                    images.put(filename, result.first)
                }
                if (scanImageFaceUrl != null) {
                    result = downloadFileAsBlob(scanImageFaceUrl, apiToken, apiSecret).bind()
                    val filename = "face.${getFileExtFromType(result.second)}"
                    images.put(filename, result.first)
                }
                if(scanlivenessImagesUrl != null) {
                    val urls = scanlivenessImagesUrl.toMutableList()
                    urls.sort() // The url list is not in sequence
                    val flattenedList = flattenList(urls)
                    var imageIndex = 0
                    for (imageUrl in flattenedList) {
                        result = downloadFileAsBlob(imageUrl, apiToken, apiSecret).bind()
                        val filename = "liveness-${++imageIndex}.${getFileExtFromType(result.second)}"
                        images.put(filename, result.first)
                    }
                }
                VendorScanInformation(scanId, scanReference, scanDetails, images)
            }.fix()
        }.unsafeRunSync()
    }

    /**
     * Deletes the scan information from Jumio database.
     */
    fun deleteScanInformation(vendorScanId: String, baserUrl:String, username: String, password: String): Either<StoreError, Unit> {
        val url = URL("$baserUrl/$vendorScanId")
        val httpConn = url.openConnection() as HttpURLConnection
        val userpass = "$username:$password"
        val authHeader = "Basic ${Base64.getEncoder().encodeToString(userpass.toByteArray())}"
        httpConn.setRequestProperty("Authorization", authHeader)
        httpConn.setRequestProperty("Accept", "application/json")
        httpConn.setRequestProperty("User-Agent", "ScanInformationStore")
        httpConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        httpConn.doOutput = true;
        httpConn.setRequestMethod("DELETE");

        try {
            val responseCode = httpConn.responseCode
            // always check HTTP response code first
            if (responseCode != HttpURLConnection.HTTP_OK) {
                val statusMessage = "$responseCode: ${httpConn.responseMessage}"
                return Either.left(FileDeleteError(url.toString(), statusMessage));
            }
            return Unit.right()
        } catch (e: IOException) {
            val statusMessage = "IOException: $e"
            return Either.left(FileDeleteError(url.toString(), statusMessage))
        } finally {
            httpConn.disconnect()
        }
    }
    /**
     * Creates the zip file from VendorScanInformation.
     */
    fun generateZipFile(vendorData: VendorScanInformation): Either<StoreError, ByteArray> {
        val outputStream = ByteArrayOutputStream()
        val zos = ZipOutputStream(BufferedOutputStream(outputStream))

        try {
            zos.putNextEntry(ZipEntry("postdata.json"))
            zos.write(vendorData.details.toByteArray())
            zos.closeEntry()
            // Append all images
            if (vendorData.images != null) {
                vendorData.images?.map { (filename, data) ->
                    zos.putNextEntry(ZipEntry(filename))
                    zos.write(data.toByteArray())
                    zos.closeEntry()
                    Unit
                }
            }
            zos.finish()
        } catch (e: IOException) {
            return Either.left(NotCreatedError(VendorScanData.TYPE_NAME.s, vendorData.id))
        } finally {
            zos.close()
        }
        return Either.right(outputStream.toByteArray())
    }

    /**
     * Creates the file extension from  mime-type.
     */
    private fun getFileExtFromType(mimeType: String): String {
        val idx = mimeType.lastIndexOf("/")
        if (idx == -1) {
            return mimeType
        } else {
            return mimeType.drop(idx + 1)
        }
    }


    /**
     * Upload the byte array to the given cloud storage object.
     */
    fun uploadFileToCloudStorage(bucket: String, fileName: String, data: ByteArray): Either<StoreError, String> {
        val storage = StorageOptions.getDefaultInstance().getService()
        val blobId = BlobId.of(bucket, fileName)
        val blobInfo = BlobInfo.newBuilder(blobId).setContentType("application/octet-stream").build()
        var mediaLink: String
        try {
            val blob = storage.create(blobInfo, data)
            mediaLink = blob.mediaLink
        } catch (e: StorageException) {
            return Either.left(NotCreatedError(VendorScanData.TYPE_NAME.s, "$bucket/$fileName"))
        }
        return Either.right(mediaLink)
    }

    /**
     * Save byte array as local file, used only for testing
     */
    fun saveLocalFile(fileName: String, data: ByteArray): Either<StoreError, String> {
        val fos = FileOutputStream(File(fileName))
        try {
            fos.write(data)
            fos.close()
        } catch (e: IOException) {
            return Either.left(NotCreatedError(VendorScanData.TYPE_NAME.s, "$fileName"))
        }
        return Either.right(fileName)
    }


    fun loadLocalZipFile(fileName: String): Either<StoreError, ZipInputStream> {
        try {
            val fis = FileInputStream(File(fileName))
            return Either.right(ZipInputStream(fis))
        } catch (e: FileNotFoundException) {
            return Either.left(NotCreatedError(VendorScanData.TYPE_NAME.s, "$fileName"))
        }
    }

    @JvmStatic
    fun main(args: Array<String>) {
        val fileURL = "https://jdbc.postgresql.org/download/postgresql-9.2-1002.jdbc4.jar"
        try {
            val ret = downloadFileAsBlob(fileURL, "", "")
            println(ret)
        } catch (ex: IOException) {
            ex.printStackTrace()
        }
        __testDecryption()
    }

    private fun __testDecryption() {
        // The files created during the acceptance tests can be verified using this function
        // Download encrypted files created in the root folder of prime docker image
        // Find files by logging into the docker image `docker exec -ti prime bash`
        // Copy files from docker image using `docker cp prime:/global_f1a6a509-7998-405c-b186-08983c91b422.zip.tk .`
        // Replace the path for the input files in the method & run.
        TinkConfig.register()
        val file = File("global_f1a6a509-7998-405c-b186-08983c91b422.zip.tk") // File downloaded form docker image after AT
        val fis = FileInputStream(file)
        val data = ByteArray(file.length().toInt())
        fis.read(data)
        fis.close()
        val pvtKeysetFilename = "prime/config/test_keyset_pvt_cltxt" // The test private keys used in AT
        val keysetHandle = CleartextKeysetHandle.read(JsonKeysetReader.withFile(File(pvtKeysetFilename)))
        val hybridDecrypt = HybridDecryptFactory.getPrimitive(keysetHandle)
        val decrypted = hybridDecrypt.decrypt(data, null)
        saveLocalFile("decrypted.zip", decrypted)
    }
}