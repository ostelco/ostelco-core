//usr/bin/env go run "$0" "$@"; exit "$?"
package main

import (
	"bufio"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"github.com/ostelco/ostelco-core/sim-administration/sim-batch-management/es2plus"
	"github.com/ostelco/ostelco-core/sim-administration/sim-batch-management/model"
	"github.com/ostelco/ostelco-core/sim-administration/sim-batch-management/outfileparser"
	"github.com/ostelco/ostelco-core/sim-administration/sim-batch-management/store"
	"github.com/ostelco/ostelco-core/sim-administration/sim-batch-management/uploadtoprime"
	kingpin "gopkg.in/alecthomas/kingpin.v2"
	"io"
	"log"
	"os"
	"strings"
	"sync"
)

//  "gopkg.in/alecthomas/kingpin.v2"
var (
	// TODO: Enable, but also make it have an effect.
	// debug    = kingpin.Flag("debug", "enable debug mode").Default("false").Bool()

	es2             = kingpin.Command("es2", "Do things with the ES2+ protocol")
	es2cmd          = es2.Arg("cmd", "The ES2+ subcommand, one of get-status, recover-profile, download-order, confirm-order, cancel-profile, bulk-activate-iccids, activate-iccid ").Required().String()
	es2iccid        = es2.Arg("iccid", "Iccid of profile to manipulate").Required().String()
	es2Target       = es2.Arg("target-state", "Target state of recover-profile or cancel-profile command").Default("AVAILABLE").String()
	es2CertFilePath = es2.Flag("cert", "Certificate pem file.").Required().String()
	es2KeyFilePath  = es2.Flag("key", "Certificate key file.").Required().String()
	es2Hostport     = es2.Flag("hostport", "host:port of ES2+ endpoint.").Required().String()
	es2RequesterId  = es2.Flag("requesterid", "ES2+ requester ID.").Required().String()

	//
	// Convert an output (.out) file from an sim profile producer into an input file
	// for Prime.
	//

	/**
	 * OLD COMMENTS: Not yet reworked into doc for this script, but mostly accurate
	 *  nonetheless.
	 *
	 * This program is intended to be used from the command line, and will convert an
	 * output file from a sim card vendor into an input file for a HSS. The assumptions
	 * necessary for this to work are:
	 *
	 *  * The SIM card vendor produces output files similar to the example .out file
	 *     found in the same source directory as this program
	 *
	 *  * The HSS accepts input as a CSV file, with header line 'ICCID, IMSI, KI' and subsequent
	 *    lines containing ICCID/IMSI/Ki fields, all separated by commas.
	 *
	 * Needless to say, the outmost care should be taken when handling Ki values and
	 * this program must, as a matter of course, be considered a security risk, as
	 * must all  software that touch SIM values.
	 *
	 * With that caveat in place, the usage of this program typically looks like
	 * this:
	 *
	 *    ./outfile_to_hss_input_converter.go  \
	 *              -input-file sample_out_file_for_testing.out
	 *              -output-file-prefix  ./hss-input-for-
	 *
	 * (followed by cryptographically strong erasure of the .out file,
	 *  encapsulation of the .csv file in strong cryptography etc., none
	 *  of which are handled by this script).
	 */

	spUpload                 = kingpin.Command("sim-profile-upload", "Convert an output (.out) file from an sim profile producer into an input file for an HSS.")
	spUploadInputFile        = spUpload.Flag("input-file", "path to .out file used as input file").Required().String()
	spUploadOutputFilePrefix = spUpload.Flag("output-file-prefix",
		"prefix to path to .csv file used as input file, filename will be autogenerated").Required().String()

	// TODO: Check if this can be used for the key files.
	// postImage   = post.Flag("image", "image to post").ExistingFile()

	// TODO ???
	batch = kingpin.Command("batch", "Utility for persisting and manipulating sim card batches.")

	listBatches = kingpin.Command("list-batches", "List all known batches.")

	describeBatch      = kingpin.Command("describe-batch", "Describe a batch with a particular name.")
	describeBatchBatch = describeBatch.Arg("batch", "The batch to describe").String()

	generateInputFile          = kingpin.Command("generate-input-file", "Generate input file for a named batch using stored parameters")
	generateInputFileBatchname = generateInputFile.Arg("batchname", "The batch to generate the input file for.").String()

	addMsisdnFromFile        = kingpin.Command("add-msisdn-from-file", "Add MSISDN from CSV file containing at least ICCID/MSISDN, but also possibly IMSI.")
	addMsisdnFromFileBatch   = addMsisdnFromFile.Flag("batch", "The batch to augment").Required().String()
	addMsisdnFromFileCsvfile = addMsisdnFromFile.Flag("csv-file", "The CSV file to read from").Required().ExistingFile()

	generateUploadBatch      = kingpin.Command("generate-batch-upload-script", "Generate a batch upload script")
	generateUploadBatchBatch = generateUploadBatch.Arg("batch", "The batch to generate upload script from").String()

	db           = kingpin.Command("declare-batch", "Declare a batch to be persisted, and used by other commands")
	dbName       = db.Flag("name", "Unique name of this batch").Required().String()
	dbCustomer   = db.Flag("customer", "Name of the customer of this batch (with respect to the sim profile vendor)").Required().String()
	dbBatchNo    = db.Flag("batch-no", "Unique number of this batch (with respect to the profile vendor)").Required().String()
	dbOrderDate  = db.Flag("order-date", "Order date in format ddmmyyyy").Required().String()
	dbFirstIccid = db.Flag("first-rawIccid",
		"An 18 or 19 digit long string.  The 19-th digit being a luhn luhnChecksum digit, if present").Required().String()
	dbLastIccid = db.Flag("last-rawIccid",
		"An 18 or 19 digit long string.  The 19-th digit being a luhn luhnChecksum digit, if present").Required().String()
	dbFirstIMSI         = db.Flag("first-imsi", "First IMSI in batch").Required().String()
	dbLastIMSI          = db.Flag("last-imsi", "Last IMSI in batch").Required().String()
	dbFirstMsisdn       = db.Flag("first-msisdn", "First MSISDN in batch").Required().String()
	dbLastMsisdn        = db.Flag("last-msisdn", "Last MSISDN in batch").Required().String()
	dbProfileType       = db.Flag("profile-type", "SIM profile type").Required().String()
	dbBatchLengthString = db.Flag(
		"batch-quantity",
		"Number of sim cards in batch").Required().String()

	dbHssVendor        = db.Flag("hss-vendor", "The HSS vendor").Default("M1").String()
	dbUploadHostname   = db.Flag("upload-hostname", "host to upload batch to").Default("localhost").String()
	dbUploadPortnumber = db.Flag("upload-portnumber", "port to upload to").Default("8080").String()

	dbProfileVendor = db.Flag("profile-vendor", "Vendor of SIM profiles").Default("Idemia").String()

	dbInitialHlrActivationStatusOfProfiles = db.Flag(
		"initial-hlr-activation-status-of-profiles",
		"Initial hss activation state.  Legal values are ACTIVATED and NOT_ACTIVATED.").Default("ACTIVATED").String()
)

func main() {

	db, err := store.OpenFileSqliteDatabase("foobar.db")
	if err != nil {
		panic(fmt.Sprintf("Couldn't open sqlite database.  '%s'", err))
	}

	db.GenerateTables()

	cmd := kingpin.Parse()
	switch cmd {
	case "sim-profile-upload":
		outfileparser.ConvertInputfileToOutputfile(*spUploadInputFile, *spUploadOutputFilePrefix)

	case "list-batches":

		allBatches, err := db.GetAllBatches()
		if err != nil {
			panic(err)
		}

		fmt.Println("Names of current batches: ")
		for _, batch := range allBatches {
			fmt.Printf("  %s\n", batch.Name)
		}

	case "describe-batch":

		batch, err := db.GetBatchByName(*describeBatchBatch)
		if err != nil {
			panic(err)
		}

		if batch == nil {
			fmt.Printf("No batch found with name '%s'\n", *describeBatchBatch)
		} else {
			bytes, err := json.MarshalIndent(batch, "    ", "     ")
			if err != nil {
				fmt.Println("Can't serialize", batch)
			}

			fmt.Printf("%v\n", string(bytes))
		}

	case "generate-batch-upload-script":
		batch, err := db.GetBatchByName(*generateUploadBatchBatch)
		if err != nil {
			panic(err)
		}

		if batch == nil {
			fmt.Printf("No batch found with name '%s'\n", *describeBatchBatch)
		} else {
			var csvPayload = uploadtoprime.GenerateCsvPayload2(*batch)
			uploadtoprime.GeneratePostingCurlscript(batch.Url, csvPayload)
		}

	case "generate-input-file":
		batch, err := db.GetBatchByName(*generateInputFileBatchname)
		if err != nil {
			panic(err)
		}

		if batch == nil {
			fmt.Printf("No batch found with name '%s'\n", *generateInputFileBatchname)
		} else {
			var result = GenerateInputFile(batch)
			fmt.Println(result)
		}

	case "add-msisdn-from-file":
		batchName := *addMsisdnFromFileBatch
		csvFilename := *addMsisdnFromFileCsvfile

		batch, err := db.GetBatchByName(batchName)
		if err != nil {
			panic(err)
		}

		csvFile, _ := os.Open(csvFilename)
		reader := csv.NewReader(bufio.NewReader(csvFile))

		defer csvFile.Close()

		headerLine, error := reader.Read()
		if error == io.EOF {
			break
		} else if error != nil {
			log.Fatal(error)
		}

		var columnMap map[string]int
		columnMap = make(map[string]int)

		for index, fieldname := range headerLine {
			columnMap[strings.ToLower(fieldname)] = index
		}

		if _, hasIccid := columnMap["iccid"]; !hasIccid {
			panic("No ICCID  column in CSV file")
		}

		if _, hasMsisdn := columnMap["msisdn"]; !hasMsisdn {
			panic("No MSISDN  column in CSV file")
		}

		if _, hasImsi := columnMap["imsi"]; !hasImsi {
			panic("No IMSI  column in CSV file")
		}

		type csvRecord struct {
			iccid  string
			imsi   string
			msisdn string
		}

		var recordMap map[string]csvRecord
		recordMap = make(map[string]csvRecord)

		// Read all the lines into the record map.
		for {
			line, error := reader.Read()
			if error == io.EOF {
				break
			} else if error != nil {
				log.Fatal(error)
			}

			record := csvRecord{
				iccid:  line[columnMap["iccid"]],
				imsi:   line[columnMap["imsi"]],
				msisdn: line[columnMap["msisdn"]],
			}

			if _, duplicateRecordExists := recordMap[record.iccid]; duplicateRecordExists {
				panic(fmt.Sprintf("Duplicate ICCID record in map: %s", record.iccid))
			}

			recordMap[record.iccid] = record
		}

		simEntries, err := db.GetAllSimEntriesForBatch(batch.BatchId)
		if err != nil {
			panic(err)
		}

		// Check for compatibility
		tx := db.Begin()
		noOfRecordsUpdated := 0
		for _, entry := range simEntries {
			record, iccidRecordIsPresent := recordMap[entry.Iccid]
			if !iccidRecordIsPresent {
				tx.Rollback()
				panic(fmt.Sprintf("ICCID not in batch: %s", entry.Iccid))
			}

			if entry.Imsi != record.imsi {
				tx.Rollback()
				panic(fmt.Sprintf("IMSI mismatch for ICCID=%s.  Batch has %s, csv file has %s", entry.Iccid, entry.Imsi, record.iccid))
			}

			if entry.Msisdn != "" && record.msisdn != "" && record.msisdn != entry.Msisdn {
				tx.Rollback()
				panic(fmt.Sprintf("MSISDN mismatch for ICCID=%s.  Batch has %s, csv file has %s", entry.Iccid, entry.Msisdn, record.msisdn))
			}

			if entry.Msisdn == "" && record.msisdn != "" {
				err = db.UpdateSimEntryMsisdn(entry.SimId, record.msisdn)
				if err != nil {
					tx.Rollback()
					panic(err)
				}
				noOfRecordsUpdated += 1
			}
		}
		tx.Commit()

		fmt.Printf("Updated %d of a total of %d records in batch '%s'\n", noOfRecordsUpdated, len(simEntries), batchName)

	case "declare-batch":
		fmt.Println("Declare batch")
		db.DeclareBatch(
			*dbName,
			*dbCustomer,
			*dbBatchNo,
			*dbOrderDate,
			*dbFirstIccid,
			*dbLastIccid,
			*dbFirstIMSI,
			*dbLastIMSI,
			*dbFirstMsisdn,
			*dbLastMsisdn,
			*dbProfileType,
			*dbBatchLengthString,
			*dbHssVendor,
			*dbUploadHostname,
			*dbUploadPortnumber,
			*dbProfileVendor,
			*dbInitialHlrActivationStatusOfProfiles)

	case "es2":

		// TODO: Vet all the parameters, they can  very easily be bogus.
		client := es2plus.Client(*es2CertFilePath, *es2KeyFilePath, *es2Hostport, *es2RequesterId)
		iccid := *es2iccid
		switch *es2cmd {

		case "get-status":
			result, err := client.GetStatus(iccid)
			if err != nil {
				panic(err)
			}

			fmt.Printf("iccid='%s', state='%s', acToken='%s'\n", iccid, (*result).State, (*result).ACToken)
		case "recover-profile":
			checkEs2TargetState(es2Target)
			result, err := client.RecoverProfile(iccid, *es2Target)
			if err != nil {
				panic(err)
			}
			fmt.Println("result -> ", result)
		case "download-order":
			result, err := client.DownloadOrder(iccid)
			if err != nil {
				panic(err)
			}
			fmt.Println("result -> ", result)
		case "confirm-order":
			result, err := client.ConfirmOrder(iccid)
			if err != nil {
				panic(err)
			}
			fmt.Println("result -> ", result)
		case "activate-iccid":
			result, err := client.ActivateIccid(iccid)

			if err != nil {
				panic(err)
			}
			fmt.Printf("%s, %s\n", iccid, result.ACToken)

		case "set-batch-activation-codes":
			batchName := iccid

			fmt.Printf("Getting batch  named %s\n", batchName)

			batch, err := db.GetBatchByName(batchName)
			if err != nil {
				fmt.Errorf("Unknown batch '%s'\n", batchName)
			}

			entries, err := db.GetAllSimEntriesForBatch(batch.BatchId)
			if err != nil {
				panic(err)
			}

			// XXX Is this really necessary? I don't think so
			var mutex = &sync.Mutex{}

			fmt.Println("Starting to loop over entries")
			var waitgroup sync.WaitGroup

			// Limit concurency of the for-loop below
			// to 160 goroutines.  The reason is that if we get too
			// many we run out of file descriptors, and we don't seem to
			// get much speedup after hundred or so.
			concurrency := 160
			sem := make(chan bool, concurrency)
			tx := db.Begin()
			for _, entry := range entries {

				//
				// Only apply activation if not already noted in the
				// database.
				if entry.ActivationCode == "" {

					sem <- true

					waitgroup.Add(1)
					go func(entry model.SimEntry) {

						defer func() { <-sem }()

						result, err := client.ActivateIccid(entry.Iccid)
						if err != nil {
							panic(err)
						}
						fmt.Printf("%s, %s\n", entry.Iccid, result.ACToken)
						mutex.Lock()

						db.UpdateActivationCode(entry.SimId, result.ACToken)

						mutex.Unlock()
						waitgroup.Done()
					}(entry)
				}
			}

			waitgroup.Wait()
			for i := 0; i < cap(sem); i++ {
				sem <- true
			}
			tx.Commit()

		case "bulk-activate-iccids":

			file, err := os.Open(iccid)
			if err != nil {
				log.Fatal(err)
			}
			defer file.Close()

			scanner := bufio.NewScanner(file)
			var mutex = &sync.Mutex{}
			var waitgroup sync.WaitGroup
			for scanner.Scan() {
				iccid := scanner.Text()
				waitgroup.Add(1)
				go func(i string) {

					result, err := client.ActivateIccid(i)
					if err != nil {
						panic(err)
					}
					mutex.Lock()
					fmt.Printf("%s, %s\n", i, result.ACToken)
					mutex.Unlock()
					waitgroup.Done()
				}(iccid)
			}

			waitgroup.Wait()

			if err := scanner.Err(); err != nil {
				log.Fatal(err)
			}

		case "cancel-profile":
			checkEs2TargetState(es2Target)
			_, err := client.CancelOrder(iccid, *es2Target)
			if err != nil {
				panic(err)
			}
		default:
			panic(fmt.Sprintf("Unknown es2+ subcommand '%s', try --help", *es2cmd))
		}
	case "batch":
		fmt.Println("Doing the batch thing.")
		// storage.doTheBatchThing()
	default:
		panic(fmt.Sprintf("Unknown command: '%s'\n", cmd))
	}
}

func checkEs2TargetState(target *string) {
	if *target != "AVAILABLE" {
		panic("Target ES2+ state unexpected, legal value(s) is(are): 'AVAILABLE'")
	}
}

///
///    Input batch management
///

func GenerateInputFile(batch *model.Batch) string {
	result := "*HEADER DESCRIPTION\n" +
		"***************************************\n" +
		fmt.Sprintf("Customer        : %s\n", (*batch).Customer) +
		fmt.Sprintf("ProfileType     : %s\n", (*batch).ProfileType) +
		fmt.Sprintf("Order Date      : %s\n", (*batch).OrderDate) +
		fmt.Sprintf("Batch No        : %s\n", (*batch).BatchNo) +
		fmt.Sprintf("Quantity        : %d\n", (*batch).Quantity) +
		"***************************************\n" +
		"*INPUT VARIABLES\n" +
		"***************************************\n" +
		"var_In:\n" +
		fmt.Sprintf(" ICCID: %s\n", (*batch).FirstIccid) +
		fmt.Sprintf("IMSI: %s\n", (*batch).FirstImsi) +
		"***************************************\n" +
		"*OUTPUT VARIABLES\n" +
		"***************************************\n" +
		"var_Out: ICCID/IMSI/KI\n"
	return result
}
